<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ton wallet scanner - by tk6vn</title>
  <style>
    *
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Courier New', monospace;
      background: #000;
      color: #ffffff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      overflow-x: hidden;
    }
    
    .container {
      width: 100%;
      max-width: 1200px;
      background: #000;
      border: 1px solid #9E9E9E;
      padding: 20px;
      margin: 20px 0;
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 15px;
      border-bottom: 1px solid #9E9E9E;
    }
    
    .header h1 {
      font-size: 24px;
      font-weight: normal;
      text-transform: lowercase;
      color: #9E9E9E;
      margin-bottom: 5px;
    }
    
    .header p {
      font-size: 12px;
      color: #9E9E9E;
      opacity: 0.7;
    }
    
    .config {
      margin-bottom: 25px;
      padding: 15px;
      border: 1px solid #333;
      background: #111;
    }
    
    .config-item {
      margin-bottom: 15px;
    }
    
    .config-label {
      color: #9E9E9E;
      margin-bottom: 5px;
      font-size: 12px;
      opacity: 0.8;
    }
    
    input, select {
      width: 100%;
      padding: 8px;
      background: #000;
      border: 1px solid #333;
      color: #9E9E9E;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin-bottom: 25px;
      font-size: 14px;
    }
    
    .stat-item {
      padding: 10px;
      border: 1px solid #333;
      background: #111;
    }
    
    .stat-label {
      color: #9E9E9E;
      margin-bottom: 5px;
      font-size: 12px;
      opacity: 0.8;
    }
    
    .stat-value {
      font-size: 18px;
      color: #fff;
    }
    
    .workers-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
    }
    
    .worker-item {
      padding: 15px;
      border: 1px solid #333;
      background: #111;
      font-size: 12px;
    }
    
    .worker-header {
      color: #9E9E9E;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid #333;
    }
    
    .worker-data {
      margin-bottom: 8px;
    }
    
    .mnemonic-value {
      color: #FFE600;
      word-break: break-all;
      font-size: 11px;
      line-height: 1.3;
    }
    
    .address-value {
      color: #00ffff;
      font-size: 11px;
      word-break: break-all;
    }
    
    .balance-value {
      font-weight: bold;
    }
    
    .balance-zero {
      color: #ff0000;
    }
    
    .balance-positive {
      color: #00ff00;
    }
    
    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .btn {
      padding: 10px 20px;
      border: 1px solid #00ff00;
      background: #000;
      color: #00ff00;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      cursor: pointer;
      text-transform: lowercase;
      transition: all 0.2s ease;
    }
    
    .btn:hover:not(:disabled) {
      background: #00ff00;
      color: #000;
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: #333;
      color: #333;
    }
    
    .status {
      text-align: center;
      margin-bottom: 20px;
      padding: 10px;
      border: 1px solid #333;
      background: #111;
      font-size: 14px;
    }
    
    .status-stopped {
      color: #ff0000;
    }
    
    .status-running {
      color: #00ff00;
    }
    
    .last-update {
      text-align: center;
      margin-bottom: 25px;
      font-size: 12px;
      color: #666;
    }
    
    .found-wallets {
      border: 1px solid #333;
      background: #111;
      padding: 15px;
    }
    
    .found-wallets h3 {
      color: #00ff00;
      margin-bottom: 15px;
      font-size: 16px;
      text-align: center;
      text-transform: lowercase;
      font-weight: normal;
    }
    
    .wallets-list {
      max-height: 300px;
      overflow-y: auto;
    }
    
    .wallet-item {
      background: #000;
      padding: 12px;
      margin-bottom: 10px;
      border: 1px solid #333;
      font-size: 12px;
    }
    
    .wallet-item p {
      margin-bottom: 6px;
    }
    
    .wallet-mnemonic {
      color: #00ff00;
      word-break: break-all;
      font-size: 11px;
      line-height: 1.3;
    }
    
    .wallet-address {
      color: #00ffff;
      font-size: 11px;
      word-break: break-all;
    }
    
    .wallet-balance {
      color: #00ff00;
      font-weight: bold;
    }
    
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 12px 18px;
      border: 1px solid #00ff00;
      background: #000;
      color: #00ff00;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      z-index: 1000;
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
    }
    
    .notification.show {
      opacity: 1;
      transform: translateX(0);
    }
    
    @media (max-width: 768px) {
      .stats {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .workers-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>multi-threaded ton scanner</h1>
      <p>by tk6vn - parallel wallet checking</p>
    </div>
    
    <div class="config">
      <div class="config-item">
        <div class="config-label">number of workers (threads)</div>
        <input type="number" id="workersCount" value="3" min="1" max="10">
      </div>
      <div class="config-item">
        <div class="config-label">requests per second limit</div>
        <input type="number" id="rpsLimit" value="2" min="1" max="5">
      </div>
    </div>
    
    <div class="stats">
      <div class="stat-item">
        <div class="stat-label">total generated</div>
        <div class="stat-value" id="totalGenerated">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">active workers</div>
        <div class="stat-value" id="activeWorkers">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">wallets with balance</div>
        <div class="stat-value" id="foundCount">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">requests rate</div>
        <div class="stat-value" id="requestRate">0/s</div>
      </div>
    </div>
    
    <div class="workers-grid" id="workersGrid">
      <!-- Workers will be dynamically added here -->
    </div>
    
    <div class="controls">
      <button class="btn" id="startBtn">start scanning</button>
      <button class="btn" id="stopBtn" disabled>stop scanning</button>
      <button class="btn" id="addWorkerBtn">+ add worker</button>
      <button class="btn" id="removeWorkerBtn">- remove worker</button>
    </div>
    
    <div class="status status-stopped" id="statusMessage">
      scanner status: stopped
    </div>
    
    <div class="last-update">
      last update: <span id="lastUpdate">-</span>
    </div>
    
    <div class="found-wallets">
      <h3>found wallets with balance</h3>
      <div class="wallets-list" id="walletsList">
        <p style="text-align: center; color: #666;">no wallets with balance found yet</p>
      </div>
    </div>
  </div>

  <div class="notification" id="notification"></div>

  <script type="module">
    // Import TON libraries
    import { mnemonicToWalletKey, mnemonicNew } from "https://esm.sh/@ton/crypto";
    import { WalletContractV3R1, WalletContractV3R2, WalletContractV4, WalletContractV5R1 } from "https://esm.sh/@ton/ton";

    // Main application state
    const state = {
      isScanning: false,
      totalGenerated: 0,
      foundCount: 0,
      activeWorkers: 0,
      workers: [],
      requestRate: 0,
      foundWallets: [],
      lastRequestTime: 0
    };

    // Elements
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const addWorkerBtn = document.getElementById('addWorkerBtn');
    const removeWorkerBtn = document.getElementById('removeWorkerBtn');
    const workersCountInput = document.getElementById('workersCount');
    const rpsLimitInput = document.getElementById('rpsLimit');
    const totalGeneratedEl = document.getElementById('totalGenerated');
    const activeWorkersEl = document.getElementById('activeWorkers');
    const foundCountEl = document.getElementById('foundCount');
    const requestRateEl = document.getElementById('requestRate');
    const statusMessageEl = document.getElementById('statusMessage');
    const lastUpdateEl = document.getElementById('lastUpdate');
    const walletsListEl = document.getElementById('walletsList');
    const workersGridEl = document.getElementById('workersGrid');
    const notificationEl = document.getElementById('notification');

    // Initialize workers
    function initializeWorkers() {
      const workersCount = parseInt(workersCountInput.value) || 3;
      state.workers = Array(workersCount).fill().map((_, index) => ({
        id: index + 1,
        status: 'idle',
        generated: 0,
        found: 0,
        currentPhrase: '',
        currentAddress: '',
        currentVersion: '',
        currentBalance: 0
      }));
      renderWorkers();
    }

    // Render workers grid
    function renderWorkers() {
      workersGridEl.innerHTML = '';
      state.workers.forEach(worker => {
        const workerEl = document.createElement('div');
        workerEl.className = 'worker-item';
        workerEl.innerHTML = `
          <div class="worker-header">worker #${worker.id} - ${worker.status}</div>
          <div class="worker-data">
            <div>generated: ${worker.generated}</div>
            <div>found: ${worker.found}</div>
          </div>
          <div class="worker-data">
            <div>phrase: <span class="mnemonic-value">${worker.currentPhrase || 'waiting...'}</span></div>
            <div>version: ${worker.currentVersion || '-'}</div>
            <div>address: <span class="address-value">${worker.currentAddress || '-'}</span></div>
            <div>balance: <span class="balance-value ${worker.currentBalance > 0 ? 'balance-positive' : 'balance-zero'}">${worker.currentBalance > 0 ? worker.currentBalance.toFixed(6) : '0'} TON</span></div>
          </div>
        `;
        workersGridEl.appendChild(workerEl);
      });
      activeWorkersEl.textContent = state.workers.length;
    }

    // Update worker status
    function updateWorkerStatus(workerId, updates) {
      const worker = state.workers.find(w => w.id === workerId);
      if (worker) {
        Object.assign(worker, updates);
        renderWorkers();
      }
    }

    // Get balance function with rate limiting
    async function getBalance(address) {
      const now = Date.now();
      const rpsLimit = parseInt(rpsLimitInput.value) || 2;
      const minDelay = 1000 / rpsLimit;
      
      if (state.lastRequestTime > 0) {
        const timeSinceLastRequest = now - state.lastRequestTime;
        if (timeSinceLastRequest < minDelay) {
          await new Promise(resolve => setTimeout(resolve, minDelay - timeSinceLastRequest));
        }
      }
      
      state.lastRequestTime = Date.now();
      state.requestRate = rpsLimit;
      requestRateEl.textContent = `${rpsLimit}/s`;
      
      try {
        const balanceUrl = `https://toncenter.com/api/v2/getAddressInformation?address=${address}`;
        const response = await fetch(balanceUrl);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.ok) {
          return parseInt(data.result.balance, 10) / 1e9;
        }
        return 0;
      } catch (error) {
        console.error('Balance check error:', error);
        return 0;
      }
    }

    // Show notification
    function showNotification(message) {
      notificationEl.textContent = message;
      notificationEl.classList.add('show');
      setTimeout(() => notificationEl.classList.remove('show'), 3000);
    }

    // Update last update time
    function updateLastUpdateTime() {
      lastUpdateEl.textContent = new Date().toLocaleString();
    }

    // Update wallets list
    function updateWalletsList() {
      if (state.foundWallets.length === 0) {
        walletsListEl.innerHTML = '<p style="text-align: center; color: #666;">no wallets with balance found yet</p>';
        return;
      }
      
      walletsListEl.innerHTML = '';
      state.foundWallets.forEach(wallet => {
        const walletItem = document.createElement('div');
        walletItem.className = 'wallet-item';
        walletItem.innerHTML = `
          <p><strong>worker:</strong> ${wallet.workerId}</p>
          <p><strong>version:</strong> ${wallet.version}</p>
          <p><strong>mnemonic:</strong> <span class="wallet-mnemonic">${wallet.mnemonic}</span></p>
          <p><strong>address:</strong> <span class="wallet-address">${wallet.address}</span></p>
          <p><strong>balance:</strong> <span class="wallet-balance">${wallet.balance.toFixed(6)} TON</span></p>
          <p><strong>found:</strong> ${new Date(wallet.timestamp).toLocaleString()}</p>
        `;
        walletsListEl.appendChild(walletItem);
      });
    }

    // Save data to localStorage
    function saveData() {
      const data = {
        totalGenerated: state.totalGenerated,
        foundCount: state.foundCount,
        foundWallets: state.foundWallets,
        lastUpdate: new Date().toISOString()
      };
      localStorage.setItem('tonMultiScannerData', JSON.stringify(data));
      updateLastUpdateTime();
    }

    // Load saved data
    function loadSavedData() {
      const savedData = localStorage.getItem('tonMultiScannerData');
      if (savedData) {
        const data = JSON.parse(savedData);
        state.totalGenerated = data.totalGenerated || 0;
        state.foundCount = data.foundCount || 0;
        state.foundWallets = data.foundWallets || [];
        
        totalGeneratedEl.textContent = state.totalGenerated.toLocaleString();
        foundCountEl.textContent = state.foundCount.toLocaleString();
        updateWalletsList();
      }
    }

    // Worker function - последовательная проверка всех версий кошельков
    async function runWorker(workerId) {
      while (state.isScanning) {
        try {
          updateWorkerStatus(workerId, { status: 'generating' });
          
          // Generate proper mnemonic using TON library
          const mnemonic = await mnemonicNew(24);
          const mnemonicPhrase = mnemonic.join(' ');
          
          updateWorkerStatus(workerId, {
            status: 'checking',
            currentPhrase: mnemonicPhrase,
            currentAddress: '',
            currentVersion: '',
            currentBalance: 0
          });
          
          // Get keys from mnemonic
          const keyPair = await mnemonicToWalletKey(mnemonic);
          
          // Create all wallet versions
          const walletVersions = [
            { version: 'v3R1', wallet: WalletContractV3R1.create({ workchain: 0, publicKey: keyPair.publicKey }) },
            { version: 'v3R2', wallet: WalletContractV3R2.create({ workchain: 0, publicKey: keyPair.publicKey }) },
            { version: 'v4', wallet: WalletContractV4.create({ workchain: 0, publicKey: keyPair.publicKey }) },
            { version: 'v5R1', wallet: WalletContractV5R1.create({ workchain: 0, publicKey: keyPair.publicKey }) }
          ];
          
          let foundWallet = null;
          
          // Последовательно проверяем каждую версию кошелька
          for (const { version, wallet } of walletVersions) {
            if (!state.isScanning) break; // Проверяем, не остановлен ли сканер
            
            const address = wallet.address.toString();
            
            // Обновляем UI для текущей проверяемой версии
            updateWorkerStatus(workerId, {
              currentAddress: address,
              currentVersion: version
            });
            
            // Даем время для отображения в UI
            await new Promise(resolve => setTimeout(resolve, 50));
            
            // Проверяем баланс с ограничением скорости
            const balance = await getBalance(address);
            
            if (balance > 0) {
              foundWallet = {
                workerId,
                version,
                mnemonic: mnemonicPhrase,
                address: address,
                balance: balance,
                timestamp: new Date().toISOString()
              };
              break; // Останавливаем проверку при найденном балансе
            }
          }
          
          // Update counters
          state.totalGenerated++;
          totalGeneratedEl.textContent = state.totalGenerated.toLocaleString();
          
          updateWorkerStatus(workerId, {
            generated: state.workers[workerId - 1].generated + 1,
            currentBalance: foundWallet ? foundWallet.balance : 0
          });
          
          // Check if wallet has balance
          if (foundWallet) {
            state.foundCount++;
            foundCountEl.textContent = state.foundCount.toLocaleString();
            
            state.foundWallets.unshift(foundWallet);
            updateWalletsList();
            saveData();
            
            updateWorkerStatus(workerId, {
              found: state.workers[workerId - 1].found + 1
            });
            
            showNotification(`worker #${workerId} found ${foundWallet.version} wallet with ${foundWallet.balance.toFixed(6)} TON`);
          }
          
          // Small delay between iterations
          await new Promise(resolve => setTimeout(resolve, 100));
          
        } catch (error) {
          console.error(`Worker ${workerId} error:`, error);
          updateWorkerStatus(workerId, { 
            status: 'error', 
            currentBalance: -1,
            currentAddress: 'Error',
            currentVersion: 'Error'
          });
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }
      
      updateWorkerStatus(workerId, { 
        status: 'idle',
        currentAddress: '',
        currentVersion: ''
      });
    }

    // Start scanning
    startBtn.addEventListener('click', async () => {
      state.isScanning = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;
      statusMessageEl.textContent = 'scanner status: running';
      statusMessageEl.className = 'status status-running';
      
      initializeWorkers();
      
      // Start all workers
      state.workers.forEach(worker => {
        runWorker(worker.id);
      });
      
      showNotification('multi-threaded scanner started');
    });

    // Stop scanning
    stopBtn.addEventListener('click', () => {
      state.isScanning = false;
      startBtn.disabled = false;
      stopBtn.disabled = true;
      statusMessageEl.textContent = 'scanner status: stopped';
      statusMessageEl.className = 'status status-stopped';
      
      showNotification('scanner stopped');
    });

    // Add worker
    addWorkerBtn.addEventListener('click', () => {
      const newWorkerId = state.workers.length + 1;
      state.workers.push({
        id: newWorkerId,
        status: 'idle',
        generated: 0,
        found: 0,
        currentPhrase: '',
        currentAddress: '',
        currentVersion: '',
        currentBalance: 0
      });
      workersCountInput.value = state.workers.length;
      renderWorkers();
      
      if (state.isScanning) {
        runWorker(newWorkerId);
      }
    });

    // Remove worker
    removeWorkerBtn.addEventListener('click', () => {
      if (state.workers.length > 1) {
        state.workers.pop();
        workersCountInput.value = state.workers.length;
        renderWorkers();
      }
    });

    // Initialize
    loadSavedData();
    updateLastUpdateTime();
    initializeWorkers();
  </script>
</body>
</html>
